{"ast":null,"code":"import { checkRequired, createValidator, createValidatorAsync, isEmpty, formatErrorMessage } from './utils';\nimport locales from './locales';\nexport class MixedType {\n  constructor(name) {\n    this.required = false;\n    this.requiredMessage = '';\n    this.trim = false;\n    this.emptyAllowed = false;\n    this.rules = [];\n    this.priorityRules = [];\n    this.typeName = name;\n    this.locale = Object.assign(name ? locales[name] : {}, locales.mixed);\n  }\n  setSchemaOptions(schemaSpec, value) {\n    this.schemaSpec = schemaSpec;\n    this.value = value;\n  }\n  check() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return {\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, {\n          name: fieldName\n        })\n      };\n    }\n    const validator = createValidator(data, fieldName);\n    const checkStatus = validator(value, this.priorityRules);\n    if (checkStatus) {\n      return checkStatus;\n    }\n    if (!this.required && isEmpty(value)) {\n      return {\n        hasError: false\n      };\n    }\n    return validator(value, this.rules) || {\n      hasError: false\n    };\n  }\n  checkAsync() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return Promise.resolve({\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, {\n          name: fieldName\n        })\n      });\n    }\n    const validator = createValidatorAsync(data, fieldName);\n    return new Promise(resolve => validator(value, this.priorityRules).then(checkStatus => {\n      if (checkStatus) {\n        resolve(checkStatus);\n      }\n    }).then(() => {\n      if (!this.required && isEmpty(value)) {\n        resolve({\n          hasError: false\n        });\n      }\n    }).then(() => validator(value, this.rules)).then(checkStatus => {\n      if (checkStatus) {\n        resolve(checkStatus);\n      }\n      resolve({\n        hasError: false\n      });\n    }));\n  }\n  pushRule(rule) {\n    var _a, _b;\n    const {\n      onValid,\n      errorMessage,\n      priority,\n      params\n    } = rule;\n    const nextRule = {\n      onValid,\n      params,\n      isAsync: rule.isAsync,\n      errorMessage: errorMessage || ((_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.errorMessage)\n    };\n    if (priority) {\n      this.priorityRules.push(nextRule);\n    } else {\n      this.rules.push(nextRule);\n    }\n  }\n  addRule(onValid, errorMessage, priority) {\n    this.pushRule({\n      onValid,\n      errorMessage,\n      priority\n    });\n    return this;\n  }\n  addAsyncRule(onValid, errorMessage, priority) {\n    this.pushRule({\n      onValid,\n      isAsync: true,\n      errorMessage,\n      priority\n    });\n    return this;\n  }\n  isRequired() {\n    let errorMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.locale.isRequired;\n    let trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.required = true;\n    this.trim = trim;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n  isRequiredOrEmpty() {\n    let errorMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.locale.isRequiredOrEmpty;\n    let trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.required = true;\n    this.trim = trim;\n    this.emptyAllowed = true;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n  /**\n   * Define data verification rules based on conditions.\n   * @param validator\n   * @example\n   * MixedType().when(schema => {\n   *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);\n   * });\n   */\n  when(condition) {\n    this.addRule((value, data, filedName) => {\n      return condition(this.schemaSpec).check(value, data, filedName);\n    }, undefined, true);\n    return this;\n  }\n}\nexport default function getMixedType() {\n  return new MixedType();\n}","map":{"version":3,"sources":["../src/MixedType.ts"],"names":[],"mappings":"AASA,SACE,aAAa,EACb,eAAe,EACf,oBAAoB,EACpB,OAAO,EACP,kBAAkB,QACb,SAAS;AAChB,OAAO,OAA4B,MAAM,WAAW;AAEpD,OAAM,MAAO,SAAS,CAAA;EAapB,WAAA,CAAY,IAAe,EAAA;IAXjB,IAAA,CAAA,QAAQ,GAAG,KAAK;IAChB,IAAA,CAAA,eAAe,GAAe,EAAE;IAChC,IAAA,CAAA,IAAI,GAAG,KAAK;IACZ,IAAA,CAAA,YAAY,GAAG,KAAK;IACpB,IAAA,CAAA,KAAK,GAAgD,EAAE;IACvD,IAAA,CAAA,aAAa,GAAgD,EAAE;IAOvE,IAAI,CAAC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAA,CAAE,EAAE,OAAO,CAAC,KAAK,CAAwB;EAC9F;EAEA,gBAAgB,CAAC,UAA0C,EAAE,KAAU,EAAA;IACrE,IAAI,CAAC,UAAU,GAAG,UAAU;IAC5B,IAAI,CAAC,KAAK,GAAG,KAAK;EACpB;EAEA,KAAK,CAAA,EAA8E;IAAA,IAA7E,KAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAmB,IAAI,CAAC,KAAK;IAAA,IAAE,IAAe,GAAA,SAAA,CAAA,MAAA,OAAA,SAAA,MAAA,SAAA;IAAA,IAAE,SAA6B,GAAA,SAAA,CAAA,MAAA,OAAA,SAAA,MAAA,SAAA;IACjF,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,EAAE;MACxE,OAAO;QACL,QAAQ,EAAE,IAAI;QACd,YAAY,EAAE,kBAAkB,CAAC,IAAI,CAAC,eAAe,EAAE;UAAE,IAAI,EAAE;QAAS,CAAE;OAC3E;IACF;IAED,MAAM,SAAS,GAAG,eAAe,CAAkC,IAAI,EAAE,SAAS,CAAC;IAEnF,MAAM,WAAW,GAAG,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC;IAExD,IAAI,WAAW,EAAE;MACf,OAAO,WAAW;IACnB;IAED,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE;MACpC,OAAO;QAAE,QAAQ,EAAE;MAAK,CAAE;IAC3B;IAED,OAAO,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI;MAAE,QAAQ,EAAE;IAAK,CAAE;EAC5D;EAEA,UAAU,CAAA,EAGqB;IAAA,IAF7B,KAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAmB,IAAI,CAAC,KAAK;IAAA,IAC7B,IAAe,GAAA,SAAA,CAAA,MAAA,OAAA,SAAA,MAAA,SAAA;IAAA,IACf,SAA6B,GAAA,SAAA,CAAA,MAAA,OAAA,SAAA,MAAA,SAAA;IAE7B,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,EAAE;MACxE,OAAO,OAAO,CAAC,OAAO,CAAC;QACrB,QAAQ,EAAE,IAAI;QACd,YAAY,EAAE,kBAAkB,CAAC,IAAI,CAAC,eAAe,EAAE;UAAE,IAAI,EAAE;QAAS,CAAE;OAC3E,CAAC;IACH;IAED,MAAM,SAAS,GAAG,oBAAoB,CAAkC,IAAI,EAAE,SAAS,CAAC;IAExF,OAAO,IAAI,OAAO,CAAC,OAAO,IACxB,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,CACjC,IAAI,CAAE,WAAkD,IAAI;MAC3D,IAAI,WAAW,EAAE;QACf,OAAO,CAAC,WAAW,CAAC;MACrB;IACH,CAAC,CAAC,CACD,IAAI,CAAC,MAAK;MACT,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE;QACpC,OAAO,CAAC;UAAE,QAAQ,EAAE;QAAK,CAAE,CAAC;MAC7B;IACH,CAAC,CAAC,CACD,IAAI,CAAC,MAAM,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CACxC,IAAI,CAAE,WAAkD,IAAI;MAC3D,IAAI,WAAW,EAAE;QACf,OAAO,CAAC,WAAW,CAAC;MACrB;MACD,OAAO,CAAC;QAAE,QAAQ,EAAE;MAAK,CAAE,CAAC;IAC9B,CAAC,CAAC,CACL;EACH;EACU,QAAQ,CAAC,IAA+C,EAAA;;IAChE,MAAM;MAAE,OAAO;MAAE,YAAY;MAAE,QAAQ;MAAE;IAAM,CAAE,GAAG,IAAI;IACxD,MAAM,QAAQ,GAAG;MACf,OAAO;MACP,MAAM;MACN,OAAO,EAAE,IAAI,CAAC,OAAO;MACrB,YAAY,EAAE,YAAY,KAAI,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAG,CAAC,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,YAAY;KAC5D;IAED,IAAI,QAAQ,EAAE;MACZ,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC;KAClC,MAAM;MACL,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;IAC1B;EACH;EACA,OAAO,CACL,OAA2D,EAC3D,YAAyB,EACzB,QAAkB,EAAA;IAElB,IAAI,CAAC,QAAQ,CAAC;MAAE,OAAO;MAAE,YAAY;MAAE;IAAQ,CAAE,CAAC;IAClD,OAAO,IAAI;EACb;EACA,YAAY,CACV,OAAgE,EAChE,YAAyB,EACzB,QAAkB,EAAA;IAElB,IAAI,CAAC,QAAQ,CAAC;MAAE,OAAO;MAAE,OAAO,EAAE,IAAI;MAAE,YAAY;MAAE;IAAQ,CAAE,CAAC;IACjE,OAAO,IAAI;EACb;EACA,UAAU,CAAA,EAA+D;IAAA,IAA9D,YAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAA2B,IAAI,CAAC,MAAM,CAAC,UAAU;IAAA,IAAE,IAAI,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAG,IAAI;IACvE,IAAI,CAAC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAAC,IAAI,GAAG,IAAI;IAChB,IAAI,CAAC,eAAe,GAAG,YAAY;IACnC,OAAO,IAAI;EACb;EACA,iBAAiB,CAAA,EAAsE;IAAA,IAArE,YAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAA2B,IAAI,CAAC,MAAM,CAAC,iBAAiB;IAAA,IAAE,IAAI,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAG,IAAI;IACrF,IAAI,CAAC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAAC,IAAI,GAAG,IAAI;IAChB,IAAI,CAAC,YAAY,GAAG,IAAI;IACxB,IAAI,CAAC,eAAe,GAAG,YAAY;IACnC,OAAO,IAAI;EACb;EAEA;;;;;;;AAOG;EACH,IAAI,CAAC,SAAoE,EAAA;IACvE,IAAI,CAAC,OAAO,CACV,CAAC,KAAK,EAAE,IAAI,EAAE,SAAS,KAAI;MACzB,OAAO,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,EAAE,SAAS,CAAC;IACjE,CAAC,EACD,SAAS,EACT,IAAI,CACL;IACD,OAAO,IAAI;EACb;AACD;AAED,eAAc,SAAU,YAAY,CAAA,EAAA;EAClC,OAAO,IAAI,SAAS,EAAe;AACrC","sourceRoot":"","sourcesContent":["import { checkRequired, createValidator, createValidatorAsync, isEmpty, formatErrorMessage } from './utils';\nimport locales from './locales';\nexport class MixedType {\n    constructor(name) {\n        this.required = false;\n        this.requiredMessage = '';\n        this.trim = false;\n        this.emptyAllowed = false;\n        this.rules = [];\n        this.priorityRules = [];\n        this.typeName = name;\n        this.locale = Object.assign(name ? locales[name] : {}, locales.mixed);\n    }\n    setSchemaOptions(schemaSpec, value) {\n        this.schemaSpec = schemaSpec;\n        this.value = value;\n    }\n    check(value = this.value, data, fieldName) {\n        if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n            return {\n                hasError: true,\n                errorMessage: formatErrorMessage(this.requiredMessage, { name: fieldName })\n            };\n        }\n        const validator = createValidator(data, fieldName);\n        const checkStatus = validator(value, this.priorityRules);\n        if (checkStatus) {\n            return checkStatus;\n        }\n        if (!this.required && isEmpty(value)) {\n            return { hasError: false };\n        }\n        return validator(value, this.rules) || { hasError: false };\n    }\n    checkAsync(value = this.value, data, fieldName) {\n        if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n            return Promise.resolve({\n                hasError: true,\n                errorMessage: formatErrorMessage(this.requiredMessage, { name: fieldName })\n            });\n        }\n        const validator = createValidatorAsync(data, fieldName);\n        return new Promise(resolve => validator(value, this.priorityRules)\n            .then((checkStatus) => {\n            if (checkStatus) {\n                resolve(checkStatus);\n            }\n        })\n            .then(() => {\n            if (!this.required && isEmpty(value)) {\n                resolve({ hasError: false });\n            }\n        })\n            .then(() => validator(value, this.rules))\n            .then((checkStatus) => {\n            if (checkStatus) {\n                resolve(checkStatus);\n            }\n            resolve({ hasError: false });\n        }));\n    }\n    pushRule(rule) {\n        var _a, _b;\n        const { onValid, errorMessage, priority, params } = rule;\n        const nextRule = {\n            onValid,\n            params,\n            isAsync: rule.isAsync,\n            errorMessage: errorMessage || ((_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.errorMessage)\n        };\n        if (priority) {\n            this.priorityRules.push(nextRule);\n        }\n        else {\n            this.rules.push(nextRule);\n        }\n    }\n    addRule(onValid, errorMessage, priority) {\n        this.pushRule({ onValid, errorMessage, priority });\n        return this;\n    }\n    addAsyncRule(onValid, errorMessage, priority) {\n        this.pushRule({ onValid, isAsync: true, errorMessage, priority });\n        return this;\n    }\n    isRequired(errorMessage = this.locale.isRequired, trim = true) {\n        this.required = true;\n        this.trim = trim;\n        this.requiredMessage = errorMessage;\n        return this;\n    }\n    isRequiredOrEmpty(errorMessage = this.locale.isRequiredOrEmpty, trim = true) {\n        this.required = true;\n        this.trim = trim;\n        this.emptyAllowed = true;\n        this.requiredMessage = errorMessage;\n        return this;\n    }\n    /**\n     * Define data verification rules based on conditions.\n     * @param validator\n     * @example\n     * MixedType().when(schema => {\n     *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);\n     * });\n     */\n    when(condition) {\n        this.addRule((value, data, filedName) => {\n            return condition(this.schemaSpec).check(value, data, filedName);\n        }, undefined, true);\n        return this;\n    }\n}\nexport default function getMixedType() {\n    return new MixedType();\n}\n//# sourceMappingURL=MixedType.js.map"]},"metadata":{},"sourceType":"module"}