{"ast":null,"code":"import { MixedType } from './MixedType';\nimport { createValidator, createValidatorAsync, checkRequired, isEmpty } from './utils';\nexport class ObjectType extends MixedType {\n  constructor(errorMessage) {\n    super('object');\n    super.pushRule({\n      onValid: v => typeof v === 'object',\n      errorMessage: errorMessage || this.locale.type\n    });\n  }\n  check() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n    const check = (value, data, type) => {\n      if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {\n        return {\n          hasError: true,\n          errorMessage: type.requiredMessage\n        };\n      }\n      if (type.objectTypeSchemaSpec && typeof value === 'object') {\n        const checkResultObject = {};\n        let hasError = false;\n        Object.entries(type.objectTypeSchemaSpec).forEach(_ref => {\n          let [k, v] = _ref;\n          const checkResult = check(value[k], value, v);\n          if (checkResult === null || checkResult === void 0 ? void 0 : checkResult.hasError) {\n            hasError = true;\n          }\n          checkResultObject[k] = checkResult;\n        });\n        return {\n          hasError,\n          object: checkResultObject\n        };\n      }\n      const validator = createValidator(data, fieldName);\n      const checkStatus = validator(value, type.priorityRules);\n      if (checkStatus) {\n        return checkStatus;\n      }\n      if (!type.required && isEmpty(value)) {\n        return {\n          hasError: false\n        };\n      }\n      return validator(value, type.rules) || {\n        hasError: false\n      };\n    };\n    return check(value, data, this);\n  }\n  checkAsync() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n    const check = (value, data, type) => {\n      if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {\n        return Promise.resolve({\n          hasError: true,\n          errorMessage: this.requiredMessage\n        });\n      }\n      const validator = createValidatorAsync(data, fieldName);\n      return new Promise(resolve => {\n        if (type.objectTypeSchemaSpec && typeof value === 'object') {\n          const checkResult = {};\n          const checkAll = [];\n          const keys = [];\n          Object.entries(type.objectTypeSchemaSpec).forEach(_ref2 => {\n            let [k, v] = _ref2;\n            checkAll.push(check(value[k], value, v));\n            keys.push(k);\n          });\n          return Promise.all(checkAll).then(values => {\n            values.forEach((v, index) => {\n              checkResult[keys[index]] = v;\n            });\n            resolve({\n              object: checkResult\n            });\n          });\n        }\n        return validator(value, type.priorityRules).then(checkStatus => {\n          if (checkStatus) {\n            resolve(checkStatus);\n          }\n        }).then(() => {\n          if (!type.required && isEmpty(value)) {\n            resolve({\n              hasError: false\n            });\n          }\n        }).then(() => validator(value, type.rules)).then(checkStatus => {\n          if (checkStatus) {\n            resolve(checkStatus);\n          }\n          resolve({\n            hasError: false\n          });\n        });\n      });\n    };\n    return check(value, data, this);\n  }\n  /**\n   * @example\n   * ObjectType().shape({\n   *  name: StringType(),\n   *  age: NumberType()\n   * })\n   */\n  shape(fields) {\n    this.objectTypeSchemaSpec = fields;\n    return this;\n  }\n}\nexport default function getObjectType(errorMessage) {\n  return new ObjectType(errorMessage);\n}","map":{"version":3,"sources":["../src/ObjectType.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MixedType } from './MixedType';\nimport { createValidator, createValidatorAsync, checkRequired, isEmpty } from './utils';\nexport class ObjectType extends MixedType {\n    constructor(errorMessage) {\n        super('object');\n        super.pushRule({\n            onValid: v => typeof v === 'object',\n            errorMessage: errorMessage || this.locale.type\n        });\n    }\n    check(value = this.value, data, fieldName) {\n        const check = (value, data, type) => {\n            if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {\n                return { hasError: true, errorMessage: type.requiredMessage };\n            }\n            if (type.objectTypeSchemaSpec && typeof value === 'object') {\n                const checkResultObject = {};\n                let hasError = false;\n                Object.entries(type.objectTypeSchemaSpec).forEach(([k, v]) => {\n                    const checkResult = check(value[k], value, v);\n                    if (checkResult === null || checkResult === void 0 ? void 0 : checkResult.hasError) {\n                        hasError = true;\n                    }\n                    checkResultObject[k] = checkResult;\n                });\n                return { hasError, object: checkResultObject };\n            }\n            const validator = createValidator(data, fieldName);\n            const checkStatus = validator(value, type.priorityRules);\n            if (checkStatus) {\n                return checkStatus;\n            }\n            if (!type.required && isEmpty(value)) {\n                return { hasError: false };\n            }\n            return validator(value, type.rules) || { hasError: false };\n        };\n        return check(value, data, this);\n    }\n    checkAsync(value = this.value, data, fieldName) {\n        const check = (value, data, type) => {\n            if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {\n                return Promise.resolve({ hasError: true, errorMessage: this.requiredMessage });\n            }\n            const validator = createValidatorAsync(data, fieldName);\n            return new Promise(resolve => {\n                if (type.objectTypeSchemaSpec && typeof value === 'object') {\n                    const checkResult = {};\n                    const checkAll = [];\n                    const keys = [];\n                    Object.entries(type.objectTypeSchemaSpec).forEach(([k, v]) => {\n                        checkAll.push(check(value[k], value, v));\n                        keys.push(k);\n                    });\n                    return Promise.all(checkAll).then(values => {\n                        values.forEach((v, index) => {\n                            checkResult[keys[index]] = v;\n                        });\n                        resolve({ object: checkResult });\n                    });\n                }\n                return validator(value, type.priorityRules)\n                    .then((checkStatus) => {\n                    if (checkStatus) {\n                        resolve(checkStatus);\n                    }\n                })\n                    .then(() => {\n                    if (!type.required && isEmpty(value)) {\n                        resolve({ hasError: false });\n                    }\n                })\n                    .then(() => validator(value, type.rules))\n                    .then((checkStatus) => {\n                    if (checkStatus) {\n                        resolve(checkStatus);\n                    }\n                    resolve({ hasError: false });\n                });\n            });\n        };\n        return check(value, data, this);\n    }\n    /**\n     * @example\n     * ObjectType().shape({\n     *  name: StringType(),\n     *  age: NumberType()\n     * })\n     */\n    shape(fields) {\n        this.objectTypeSchemaSpec = fields;\n        return this;\n    }\n}\nexport default function getObjectType(errorMessage) {\n    return new ObjectType(errorMessage);\n}\n//# sourceMappingURL=ObjectType.js.map"]},"metadata":{},"sourceType":"module"}