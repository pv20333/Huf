{"ast":null,"code":"var IMPORTANT_MODIFIER = '!';\nfunction createSplitModifiers(config) {\n  var separator = config.separator || ':'; // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n\n  return function splitModifiers(className) {\n    var bracketDepth = 0;\n    var modifiers = [];\n    var modifierStart = 0;\n    for (var index = 0; index < className.length; index++) {\n      var _char = className[index];\n      if (bracketDepth === 0 && _char === separator[0]) {\n        if (separator.length === 1 || className.slice(index, index + separator.length) === separator) {\n          modifiers.push(className.slice(modifierStart, index));\n          modifierStart = index + separator.length;\n        }\n      }\n      if (_char === '[') {\n        bracketDepth++;\n      } else if (_char === ']') {\n        bracketDepth--;\n      }\n    }\n    var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);\n    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;\n    return {\n      modifiers: modifiers,\n      hasImportantModifier: hasImportantModifier,\n      baseClassName: baseClassName\n    };\n  };\n}\n/**\r\n * Sorts modifiers according to following schema:\r\n * - Predefined modifiers are sorted alphabetically\r\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\r\n */\n\nfunction sortModifiers(modifiers) {\n  if (modifiers.length <= 1) {\n    return modifiers;\n  }\n  var sortedModifiers = [];\n  var unsortedModifiers = [];\n  modifiers.forEach(function (modifier) {\n    var isArbitraryVariant = modifier[0] === '[';\n    if (isArbitraryVariant) {\n      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));\n      unsortedModifiers = [];\n    } else {\n      unsortedModifiers.push(modifier);\n    }\n  });\n  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());\n  return sortedModifiers;\n}\nexport { IMPORTANT_MODIFIER, createSplitModifiers, sortModifiers };","map":{"version":3,"sources":["../../src/lib/modifier-utils.ts"],"names":["IMPORTANT_MODIFIER","createSplitModifiers","config","separator","splitModifiers","className","bracketDepth","modifiers","modifierStart","index","length","char","slice","push","baseClassNameWithImportantModifier","substring","hasImportantModifier","startsWith","baseClassName","sortModifiers","sortedModifiers","unsortedModifiers","forEach","modifier","isArbitraryVariant","sort"],"mappings":"AAEO,IAAMA,kBAAkB,GAAG,GAA3B;AAED,SAAUC,oBAAV,CAA+BC,MAA/B,EAA6C;EAC/C,IAAMC,SAAS,GAAGD,MAAM,CAACC,SAAPD,IAAoB,GAAtC,CAD+C,CAAA;;EAI/C,OAAO,SAASE,cAAT,CAAwBC,SAAxB,EAAyC;IAC5C,IAAIC,YAAY,GAAG,CAAnB;IACA,IAAIC,SAAS,GAAG,EAAhB;IACA,IAAIC,aAAa,GAAG,CAApB;IAEA,KAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGJ,SAAS,CAACK,MAAtC,EAA8CD,KAAK,EAAnD,EAAuD;MACnD,IAAIE,KAAI,GAAGN,SAAS,CAACI,KAAD,CAApB;MAEA,IAAIH,YAAY,KAAK,CAAjBA,IAAsBK,KAAI,KAAKR,SAAS,CAAC,CAAD,CAA5C,EAAiD;QAC7C,IACIA,SAAS,CAACO,MAAVP,KAAqB,CAArBA,IACAE,SAAS,CAACO,KAAVP,CAAgBI,KAAhBJ,EAAuBI,KAAK,GAAGN,SAAS,CAACO,MAAzCL,CAAAA,KAAqDF,SAFzD,EAGE;UACEI,SAAS,CAACM,IAAVN,CAAeF,SAAS,CAACO,KAAVP,CAAgBG,aAAhBH,EAA+BI,KAA/BJ,CAAfE,CAAAA;UACAC,aAAa,GAAGC,KAAK,GAAGN,SAAS,CAACO,MAAlCF;QACH;MACJ;MAED,IAAIG,KAAI,KAAK,GAAb,EAAkB;QACdL,YAAY,EAAA;MACf,CAFD,MAEO,IAAIK,KAAI,KAAK,GAAb,EAAkB;QACrBL,YAAY,EAAA;MACf;IACJ;IAED,IAAMQ,kCAAkC,GACpCP,SAAS,CAACG,MAAVH,KAAqB,CAArBA,GAAyBF,SAAzBE,GAAqCF,SAAS,CAACU,SAAVV,CAAoBG,aAApBH,CADzC;IAEA,IAAMW,oBAAoB,GACtBF,kCAAkC,CAACG,UAAnCH,CAA8Cd,kBAA9Cc,CADJ;IAEA,IAAMI,aAAa,GAAGF,oBAAoB,GACpCF,kCAAkC,CAACC,SAAnCD,CAA6C,CAA7CA,CADoC,GAEpCA,kCAFN;IAIA,OAAO;MACHP,SAAS,EAATA,SADG;MAEHS,oBAAoB,EAApBA,oBAFG;MAGHE,aAAa,EAAbA;KAHJ;GAjCJ;AAuCH;AAED;;;;AAIG;;AACG,SAAUC,aAAV,CAAwBZ,SAAxB,EAA2C;EAC7C,IAAIA,SAAS,CAACG,MAAVH,IAAoB,CAAxB,EAA2B;IACvB,OAAOA,SAAP;EACH;EAED,IAAMa,eAAe,GAAa,EAAlC;EACA,IAAIC,iBAAiB,GAAa,EAAlC;EAEAd,SAAS,CAACe,OAAVf,CAAkB,UAACgB,QAAD,EAAa;IAC3B,IAAMC,kBAAkB,GAAGD,QAAQ,CAAC,CAAD,CAARA,KAAgB,GAA3C;IAEA,IAAIC,kBAAJ,EAAwB;MACpBJ,eAAe,CAACP,IAAhBO,CAAAA,KAAAA,CAAAA,eAAe,EAASC,iBAAiB,CAACI,IAAlBJ,EAAT,CAAmCE,MAAAA,CAAAA,CAAAA,QAAnC,CAAfH,CAAAA,CAAAA;MACAC,iBAAiB,GAAG,EAApBA;IACH,CAHD,MAGO;MACHA,iBAAiB,CAACR,IAAlBQ,CAAuBE,QAAvBF,CAAAA;IACH;GARLd,CAAAA;EAWAa,eAAe,CAACP,IAAhBO,CAAAA,KAAAA,CAAAA,eAAe,EAASC,iBAAiB,CAACI,IAAlBJ,EAAT,CAAfD;EAEA,OAAOA,eAAP;AACH","sourcesContent":["import { Config } from './types'\n\nexport const IMPORTANT_MODIFIER = '!'\n\nexport function createSplitModifiers(config: Config) {\n    const separator = config.separator || ':'\n\n    // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n    return function splitModifiers(className: string) {\n        let bracketDepth = 0\n        let modifiers = []\n        let modifierStart = 0\n\n        for (let index = 0; index < className.length; index++) {\n            let char = className[index]\n\n            if (bracketDepth === 0 && char === separator[0]) {\n                if (\n                    separator.length === 1 ||\n                    className.slice(index, index + separator.length) === separator\n                ) {\n                    modifiers.push(className.slice(modifierStart, index))\n                    modifierStart = index + separator.length\n                }\n            }\n\n            if (char === '[') {\n                bracketDepth++\n            } else if (char === ']') {\n                bracketDepth--\n            }\n        }\n\n        const baseClassNameWithImportantModifier =\n            modifiers.length === 0 ? className : className.substring(modifierStart)\n        const hasImportantModifier =\n            baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)\n        const baseClassName = hasImportantModifier\n            ? baseClassNameWithImportantModifier.substring(1)\n            : baseClassNameWithImportantModifier\n\n        return {\n            modifiers,\n            hasImportantModifier,\n            baseClassName,\n        }\n    }\n}\n\n/**\n * Sorts modifiers according to following schema:\n * - Predefined modifiers are sorted alphabetically\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\n */\nexport function sortModifiers(modifiers: string[]) {\n    if (modifiers.length <= 1) {\n        return modifiers\n    }\n\n    const sortedModifiers: string[] = []\n    let unsortedModifiers: string[] = []\n\n    modifiers.forEach((modifier) => {\n        const isArbitraryVariant = modifier[0] === '['\n\n        if (isArbitraryVariant) {\n            sortedModifiers.push(...unsortedModifiers.sort(), modifier)\n            unsortedModifiers = []\n        } else {\n            unsortedModifiers.push(modifier)\n        }\n    })\n\n    sortedModifiers.push(...unsortedModifiers.sort())\n\n    return sortedModifiers\n}\n"]},"metadata":{},"sourceType":"module"}