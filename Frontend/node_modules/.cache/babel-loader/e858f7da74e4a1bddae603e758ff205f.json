{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar tslib = require('tslib');\nvar heyListen = require('hey-listen');\nvar utils = require('@motionone/utils');\nvar stagger = require('../utils/stagger.cjs.js');\nvar animateStyle = require('../animate/animate-style.cjs.js');\nvar controls = require('../animate/utils/controls.cjs.js');\nvar keyframes = require('../animate/utils/keyframes.cjs.js');\nvar options = require('../animate/utils/options.cjs.js');\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\nvar transforms = require('../animate/utils/transforms.cjs.js');\nvar calcTime = require('./utils/calc-time.cjs.js');\nvar edit = require('./utils/edit.cjs.js');\nvar sort = require('./utils/sort.cjs.js');\nfunction timeline(definition) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  const animationDefinitions = createAnimationsFromTimeline(definition, options);\n  /**\n   * Create and start animations\n   */\n  const animationFactories = animationDefinitions.map(definition => animateStyle.animateStyle(...definition)).filter(Boolean);\n  return controls.withControls(animationFactories, options,\n  // Get the duration from the first animation definition\n  (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition) {\n  let _a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n      defaultOptions = {}\n    } = _a,\n    timelineOptions = tslib.__rest(_a, [\"defaultOptions\"]);\n  const animationDefinitions = [];\n  const elementSequences = new Map();\n  const elementCache = {};\n  const timeLabels = new Map();\n  let prevTime = 0;\n  let currentTime = 0;\n  let totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the definition array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n  for (let i = 0; i < definition.length; i++) {\n    const segment = definition[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n    if (utils.isString(segment)) {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcTime.calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n    const [elementDefinition, keyframes$1, options$1 = {}] = segment;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n    if (options$1.at !== undefined) {\n      currentTime = calcTime.calcNextTime(currentTime, options$1.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n    let maxDuration = 0;\n    /**\n     * Find all the elements specified in the definition and parse value\n     * keyframes from their timeline definitions.\n     */\n    const elements = resolveElements.resolveElements(elementDefinition, elementCache);\n    const numElements = elements.length;\n    for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n      const element = elements[elementIndex];\n      const elementSequence = getElementSequence(element, elementSequences);\n      for (const key in keyframes$1) {\n        const valueSequence = getValueSequence(key, elementSequence);\n        let valueKeyframes = keyframes.keyframesList(keyframes$1[key]);\n        const valueOptions = options.getOptions(options$1, key);\n        let {\n          duration = defaultOptions.duration || utils.defaults.duration,\n          easing = defaultOptions.easing || utils.defaults.easing\n        } = valueOptions;\n        if (utils.isEasingGenerator(easing)) {\n          const valueIsTransform = transforms.isTransform(key);\n          heyListen.invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n          const custom = easing.createAnimation(valueKeyframes,\n          // TODO We currently only support explicit keyframes\n          // so this doesn't currently read from the DOM\n          () => \"0\", valueIsTransform);\n          easing = custom.easing;\n          if (custom.keyframes !== undefined) valueKeyframes = custom.keyframes;\n          if (custom.duration !== undefined) duration = custom.duration;\n        }\n        const delay = stagger.resolveOption(options$1.delay, elementIndex, numElements) || 0;\n        const startTime = currentTime + delay;\n        const targetTime = startTime + duration;\n        /**\n         *\n         */\n        let {\n          offset = utils.defaultOffset(valueKeyframes.length)\n        } = valueOptions;\n        /**\n         * If there's only one offset of 0, fill in a second with length 1\n         *\n         * TODO: Ensure there's a test that covers this removal\n         */\n        if (offset.length === 1 && offset[0] === 0) {\n          offset[1] = 1;\n        }\n        /**\n         * Fill out if offset if fewer offsets than keyframes\n         */\n        const remainder = length - valueKeyframes.length;\n        remainder > 0 && utils.fillOffset(offset, remainder);\n        /**\n         * If only one value has been set, ie [1], push a null to the start of\n         * the keyframe array. This will let us mark a keyframe at this point\n         * that will later be hydrated with the previous value.\n         */\n        valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n        /**\n         * Add keyframes, mapping offsets to absolute time.\n         */\n        edit.addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n        maxDuration = Math.max(delay + duration, maxDuration);\n        totalDuration = Math.max(targetTime, totalDuration);\n      }\n    }\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n  elementSequences.forEach((valueSequences, element) => {\n    for (const key in valueSequences) {\n      const valueSequence = valueSequences[key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n      valueSequence.sort(sort.compareByTime);\n      const keyframes = [];\n      const valueOffset = [];\n      const valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n      for (let i = 0; i < valueSequence.length; i++) {\n        const {\n          at,\n          value,\n          easing\n        } = valueSequence[i];\n        keyframes.push(value);\n        valueOffset.push(utils.progress(0, totalDuration, at));\n        valueEasing.push(easing || utils.defaults.easing);\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(\"linear\");\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n      animationDefinitions.push([element, key, keyframes, Object.assign(Object.assign(Object.assign({}, defaultOptions), {\n        duration: totalDuration,\n        easing: valueEasing,\n        offset: valueOffset\n      }), timelineOptions)]);\n    }\n  });\n  return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n  !sequences.has(element) && sequences.set(element, {});\n  return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\nexports.createAnimationsFromTimeline = createAnimationsFromTimeline;\nexports.timeline = timeline;","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib","require","heyListen","utils","stagger","animateStyle","controls","keyframes","options","resolveElements","transforms","calcTime","edit","sort","timeline","definition","arguments","length","undefined","_a","animationDefinitions","createAnimationsFromTimeline","animationFactories","map","filter","Boolean","withControls","duration","defaultOptions","timelineOptions","__rest","elementSequences","Map","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","segment","isString","set","Array","isArray","name","calcNextTime","at","elementDefinition","keyframes$1","options$1","maxDuration","elements","numElements","elementIndex","element","elementSequence","getElementSequence","key","valueSequence","getValueSequence","valueKeyframes","keyframesList","valueOptions","getOptions","defaults","easing","isEasingGenerator","valueIsTransform","isTransform","invariant","custom","createAnimation","delay","resolveOption","startTime","targetTime","offset","defaultOffset","remainder","fillOffset","unshift","addKeyframes","Math","max","forEach","valueSequences","compareByTime","valueOffset","valueEasing","push","progress","assign","sequences","has","get"],"sources":["C:/Users/tiago/OneDrive/Documentos/GitHub/Huf/Frontend/node_modules/@motionone/dom/dist/timeline/index.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar heyListen = require('hey-listen');\nvar utils = require('@motionone/utils');\nvar stagger = require('../utils/stagger.cjs.js');\nvar animateStyle = require('../animate/animate-style.cjs.js');\nvar controls = require('../animate/utils/controls.cjs.js');\nvar keyframes = require('../animate/utils/keyframes.cjs.js');\nvar options = require('../animate/utils/options.cjs.js');\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\nvar transforms = require('../animate/utils/transforms.cjs.js');\nvar calcTime = require('./utils/calc-time.cjs.js');\nvar edit = require('./utils/edit.cjs.js');\nvar sort = require('./utils/sort.cjs.js');\n\nfunction timeline(definition, options = {}) {\n    var _a;\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\n    /**\n     * Create and start animations\n     */\n    const animationFactories = animationDefinitions\n        .map((definition) => animateStyle.animateStyle(...definition))\n        .filter(Boolean);\n    return controls.withControls(animationFactories, options, \n    // Get the duration from the first animation definition\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition, _a = {}) {\n    var { defaultOptions = {} } = _a, timelineOptions = tslib.__rest(_a, [\"defaultOptions\"]);\n    const animationDefinitions = [];\n    const elementSequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the definition array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < definition.length; i++) {\n        const segment = definition[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (utils.isString(segment)) {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcTime.calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        const [elementDefinition, keyframes$1, options$1 = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (options$1.at !== undefined) {\n            currentTime = calcTime.calcNextTime(currentTime, options$1.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        const elements = resolveElements.resolveElements(elementDefinition, elementCache);\n        const numElements = elements.length;\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n            const element = elements[elementIndex];\n            const elementSequence = getElementSequence(element, elementSequences);\n            for (const key in keyframes$1) {\n                const valueSequence = getValueSequence(key, elementSequence);\n                let valueKeyframes = keyframes.keyframesList(keyframes$1[key]);\n                const valueOptions = options.getOptions(options$1, key);\n                let { duration = defaultOptions.duration || utils.defaults.duration, easing = defaultOptions.easing || utils.defaults.easing, } = valueOptions;\n                if (utils.isEasingGenerator(easing)) {\n                    const valueIsTransform = transforms.isTransform(key);\n                    heyListen.invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n                    const custom = easing.createAnimation(valueKeyframes, \n                    // TODO We currently only support explicit keyframes\n                    // so this doesn't currently read from the DOM\n                    () => \"0\", valueIsTransform);\n                    easing = custom.easing;\n                    if (custom.keyframes !== undefined)\n                        valueKeyframes = custom.keyframes;\n                    if (custom.duration !== undefined)\n                        duration = custom.duration;\n                }\n                const delay = stagger.resolveOption(options$1.delay, elementIndex, numElements) || 0;\n                const startTime = currentTime + delay;\n                const targetTime = startTime + duration;\n                /**\n                 *\n                 */\n                let { offset = utils.defaultOffset(valueKeyframes.length) } = valueOptions;\n                /**\n                 * If there's only one offset of 0, fill in a second with length 1\n                 *\n                 * TODO: Ensure there's a test that covers this removal\n                 */\n                if (offset.length === 1 && offset[0] === 0) {\n                    offset[1] = 1;\n                }\n                /**\n                 * Fill out if offset if fewer offsets than keyframes\n                 */\n                const remainder = length - valueKeyframes.length;\n                remainder > 0 && utils.fillOffset(offset, remainder);\n                /**\n                 * If only one value has been set, ie [1], push a null to the start of\n                 * the keyframe array. This will let us mark a keyframe at this point\n                 * that will later be hydrated with the previous value.\n                 */\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n                /**\n                 * Add keyframes, mapping offsets to absolute time.\n                 */\n                edit.addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n                maxDuration = Math.max(delay + duration, maxDuration);\n                totalDuration = Math.max(targetTime, totalDuration);\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    elementSequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(sort.compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(utils.progress(0, totalDuration, at));\n                valueEasing.push(easing || utils.defaults.easing);\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            animationDefinitions.push([\n                element,\n                key,\n                keyframes,\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\n            ]);\n        }\n    });\n    return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n    !sequences.has(element) && sequences.set(element, {});\n    return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\n\nexports.createAnimationsFromTimeline = createAnimationsFromTimeline;\nexports.timeline = timeline;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}