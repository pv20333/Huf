{"ast":null,"code":"/**\r\n * @param baseConfig Config where other config will be merged into. This object will be mutated.\r\n * @param configExtension Partial config to merge into the `baseConfig`.\r\n */\nfunction mergeConfigs(baseConfig, configExtension) {\n  for (var key in configExtension) {\n    mergePropertyRecursively(baseConfig, key, configExtension[key]);\n  }\n  return baseConfig;\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar overrideTypes = /*#__PURE__*/new Set(['string', 'number', 'boolean']);\nfunction mergePropertyRecursively(baseObject, mergeKey, mergeValue) {\n  if (!hasOwnProperty.call(baseObject, mergeKey) || overrideTypes.has(typeof mergeValue) || mergeValue === null) {\n    baseObject[mergeKey] = mergeValue;\n    return;\n  }\n  if (Array.isArray(mergeValue) && Array.isArray(baseObject[mergeKey])) {\n    baseObject[mergeKey] = baseObject[mergeKey].concat(mergeValue);\n    return;\n  }\n  if (typeof mergeValue === 'object' && typeof baseObject[mergeKey] === 'object') {\n    if (baseObject[mergeKey] === null) {\n      baseObject[mergeKey] = mergeValue;\n      return;\n    }\n    for (var nextKey in mergeValue) {\n      mergePropertyRecursively(baseObject[mergeKey], nextKey, mergeValue[nextKey]);\n    }\n  }\n}\nexport { mergeConfigs };","map":{"version":3,"sources":["../../src/lib/merge-configs.ts"],"names":["baseConfig","configExtension","key","mergePropertyRecursively","hasOwnProperty","Object","prototype","overrideTypes","Set","baseObject","mergeKey","mergeValue","call","has","Array","isArray","concat","nextKey"],"mappings":"AAEA;;;AAGG;AACa,SAAA,YAAA,CAAaA,UAAb,EAAiCC,eAAjC,EAAiE;EAC7E,KAAK,IAAMC,GAAX,IAAkBD,eAAlB,EAAmC;IAC/BE,wBAAwB,CAACH,UAAD,EAAoBE,GAApB,EAAyBD,eAAe,CAACC,GAAD,CAAxC,CAAxBC;EACH;EAED,OAAOH,UAAP;AACH;AAED,IAAMI,cAAc,GAAGC,MAAM,CAACC,SAAPD,CAAiBD,cAAxC;AACA,IAAMG,aAAa,GAAA,aAAG,IAAIC,GAAJ,CAAQ,CAAC,QAAD,EAAW,QAAX,EAAqB,SAArB,CAAR,CAAtB;AAEA,SAASL,wBAAT,CACIM,UADJ,EAEIC,QAFJ,EAGIC,UAHJ,EAGuB;EAEnB,IACI,CAACP,cAAc,CAACQ,IAAfR,CAAoBK,UAApBL,EAAgCM,QAAhCN,CAAD,IACAG,aAAa,CAACM,GAAdN,CAAkB,OAAOI,UAAzBJ,CADA,IAEAI,UAAU,KAAK,IAHnB,EAIE;IACEF,UAAU,CAACC,QAAD,CAAVD,GAAuBE,UAAvBF;IACA;EACH;EAED,IAAIK,KAAK,CAACC,OAAND,CAAcH,UAAdG,CAA6BA,IAAAA,KAAK,CAACC,OAAND,CAAcL,UAAU,CAACC,QAAD,CAAxBI,CAAjC,EAAsE;IAClEL,UAAU,CAACC,QAAD,CAAVD,GAAwBA,UAAU,CAACC,QAAD,CAAVD,CAAmCO,MAAnCP,CAA0CE,UAA1CF,CAAxBA;IACA;EACH;EAED,IAAI,OAAOE,UAAP,KAAsB,QAAtB,IAAkC,OAAOF,UAAU,CAACC,QAAD,CAAjB,KAAgC,QAAtE,EAAgF;IAC5E,IAAID,UAAU,CAACC,QAAD,CAAVD,KAAyB,IAA7B,EAAmC;MAC/BA,UAAU,CAACC,QAAD,CAAVD,GAAuBE,UAAvBF;MACA;IACH;IAED,KAAK,IAAMQ,OAAX,IAAsBN,UAAtB,EAAkC;MAC9BR,wBAAwB,CACpBM,UAAU,CAACC,QAAD,CADU,EAEpBO,OAFoB,EAGpBN,UAAU,CAACM,OAAD,CAHU,CAAxBd;IAKH;EACJ;AACJ","sourcesContent":["import { Config } from './types'\n\n/**\n * @param baseConfig Config where other config will be merged into. This object will be mutated.\n * @param configExtension Partial config to merge into the `baseConfig`.\n */\nexport function mergeConfigs(baseConfig: Config, configExtension: Partial<Config>) {\n    for (const key in configExtension) {\n        mergePropertyRecursively(baseConfig as any, key, configExtension[key as keyof Config])\n    }\n\n    return baseConfig\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst overrideTypes = new Set(['string', 'number', 'boolean'])\n\nfunction mergePropertyRecursively(\n    baseObject: Record<string, unknown>,\n    mergeKey: string,\n    mergeValue: unknown,\n) {\n    if (\n        !hasOwnProperty.call(baseObject, mergeKey) ||\n        overrideTypes.has(typeof mergeValue) ||\n        mergeValue === null\n    ) {\n        baseObject[mergeKey] = mergeValue\n        return\n    }\n\n    if (Array.isArray(mergeValue) && Array.isArray(baseObject[mergeKey])) {\n        baseObject[mergeKey] = (baseObject[mergeKey] as unknown[]).concat(mergeValue)\n        return\n    }\n\n    if (typeof mergeValue === 'object' && typeof baseObject[mergeKey] === 'object') {\n        if (baseObject[mergeKey] === null) {\n            baseObject[mergeKey] = mergeValue\n            return\n        }\n\n        for (const nextKey in mergeValue) {\n            mergePropertyRecursively(\n                baseObject[mergeKey] as Record<string, unknown>,\n                nextKey,\n                mergeValue[nextKey as keyof object],\n            )\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}