'use strict';

var React = require('react');
var PropTypes = require('prop-types');
var antd = require('antd');
var icons = require('@ant-design/icons');
var lodashEs = require('lodash-es');
var classnames$1 = require('classnames');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var classnames__default = /*#__PURE__*/_interopDefaultLegacy(classnames$1);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var classnames = (function (styles) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : styles.prefix;
  var cx = classnames__default['default'].bind(styles);

  var handlePrefix = function handlePrefix(name) {
    if (lodashEs.startsWith(name, ':')) return name.replace(':', '');
    return "".concat(prefix, "-").concat(name);
  };

  return function () {
    for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
      names[_key] = arguments[_key];
    }

    return cx(lodashEs.map(names, function (name) {
      if (typeof name === 'string') {
        return handlePrefix(name);
      }

      if (_typeof(name) === 'object') {
        var returnObj = {};

        for (var key in name) {
          if (Object.prototype.hasOwnProperty.call(name, key)) {
            var element = name[key];
            returnObj[handlePrefix(key)] = element;
          }
        }

        return returnObj;
      }

      return '';
    }));
  };
});

var ROW_SELECTION = 'row____selection';
var CLASSNAME_PREFIX = 'editable-table';

var getHasValue = (function (fieldValue) {
  return fieldValue && _typeof(fieldValue) === 'object' && !(fieldValue instanceof Array) && !fieldValue._isAMomentObject;
});

var findCascaderPath = function findCascaderPath(tree, value) {
  var path = [];

  var findItem = function findItem(lTree, lValue) {
    var _iterator = _createForOfIteratorHelper(lTree),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var item = _step.value;

        if (item.value === lValue) {
          path.push(item);
          return true;
        }

        if (item.children) {
          path.push(item);

          if (findItem(item.children, lValue)) {
            return true;
          }

          path.pop();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return false;
  };

  findItem(tree, value);
  return path;
};

var _excluded = ["disabled", "formItemType", "options"],
    _excluded2 = ["name", "value"],
    _excluded3 = ["name", "value", "disabled"],
    _excluded4 = ["label", "name", "value"];

var FormItemType = function FormItemType(_ref) {
  var disabled = _ref.disabled,
      formItemType = _ref.formItemType,
      options = _ref.options,
      restProps = _objectWithoutProperties(_ref, _excluded);

  switch (formItemType) {
    case 'RADIO':
      {
        return /*#__PURE__*/React__default['default'].createElement(antd.Radio.Group, _extends({
          disabled: disabled
        }, restProps), (options || []).map(function (_ref2) {
          var name = _ref2.name,
              value = _ref2.value,
              restItem = _objectWithoutProperties(_ref2, _excluded2);

          return /*#__PURE__*/React__default['default'].createElement(antd.Radio, _extends({
            value: value,
            key: value
          }, restItem), name);
        }));
      }

    case 'SELECT':
      {
        return /*#__PURE__*/React__default['default'].createElement(antd.Select, _extends({
          disabled: disabled
        }, restProps), (options || []).map(function (_ref3) {
          var name = _ref3.name,
              value = _ref3.value,
              disabled = _ref3.disabled,
              restItem = _objectWithoutProperties(_ref3, _excluded3);

          return /*#__PURE__*/React__default['default'].createElement(antd.Select.Option, _extends({
            value: value,
            title: name,
            disabled: disabled
          }, restItem), name);
        }));
      }

    case 'DATE_PICKER':
      {
        return /*#__PURE__*/React__default['default'].createElement(antd.DatePicker, _extends({
          disabled: disabled
        }, restProps));
      }

    case 'CASCADER':
      {
        var refactor = function refactor(optionsData) {
          return (optionsData || []).map(function (item) {
            return _objectSpread2(_objectSpread2({}, item), {}, {
              label: item.label || item.name,
              children: item.children && item.children.length ? refactor(item.children) : undefined
            });
          });
        };

        return /*#__PURE__*/React__default['default'].createElement(antd.Cascader, _extends({
          options: refactor(options),
          disabled: disabled
        }, restProps));
      }

    case 'CHECKBOX':
      {
        return /*#__PURE__*/React__default['default'].createElement(antd.Checkbox.Group, _extends({
          disabled: disabled,
          options: (options || []).map(function (_ref4) {
            var label = _ref4.label,
                name = _ref4.name,
                value = _ref4.value,
                restItem = _objectWithoutProperties(_ref4, _excluded4);

            return _objectSpread2({
              label: label || name,
              value: value
            }, restItem);
          })
        }, restProps));
      }

    case 'TREE_SELECT':
      {
        var _refactor = function _refactor(optionsData) {
          return (optionsData || []).map(function (item) {
            return _objectSpread2(_objectSpread2({}, item), {}, {
              title: item.title || item.name,
              children: item.children && item.children.length ? _refactor(item.children) : undefined
            });
          });
        };

        return /*#__PURE__*/React__default['default'].createElement(antd.TreeSelect, _extends({
          disabled: disabled,
          treeData: _refactor(options)
        }, restProps));
      }

    case 'TEXTAREA':
      {
        return /*#__PURE__*/React__default['default'].createElement(antd.Input.TextArea, _extends({
          disabled: disabled
        }, restProps));
      }

    case 'INPUT_NUMBER':
      return /*#__PURE__*/React__default['default'].createElement(antd.InputNumber, _extends({
        disabled: disabled
      }, restProps));

    case 'INPUT':
    default:
      return /*#__PURE__*/React__default['default'].createElement(antd.Input, _extends({
        disabled: disabled
      }, restProps));
  }
};

FormItemType.propTypes = {
  disabled: PropTypes__default['default'].bool,
  formItemType: PropTypes__default['default'].oneOf(['RADIO', 'SELECT', 'INPUT', 'INPUT_NUMBER', 'TEXTAREA', 'DATE_PICKER', 'CASCADER', 'CHECKBOX', 'TREE_SELECT']),
  options: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
    name: PropTypes__default['default'].string,
    disabled: PropTypes__default['default'].bool,
    value: PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].number, PropTypes__default['default'].bool]),
    children: PropTypes__default['default'].array
  }))
};

var _excluded$1 = ["validateRules", "options", "formItemType", "editable", "readonly", "render", "prefixElement", "suffixElement", "cellClassName", "shouldUpdate"],
    _excluded2$1 = ["validateRules", "options", "formItemType", "editable", "readonly", "render", "shouldUpdate"];

var EditableCell = /*#__PURE__*/function (_Component) {
  _inherits(EditableCell, _Component);

  var _super = _createSuper(EditableCell);

  function EditableCell() {
    var _this;

    _classCallCheck(this, EditableCell);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.renderName = function (value, formItemType) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      if (!value) return '';

      if (formItemType === 'CASCADER') {
        return findCascaderPath(options, value).map(function (p) {
          return p.label;
        }).join('、');
      }

      if (formItemType.indexOf('SELECT') !== -1) {
        if (value instanceof Array) {
          return value.map(function (v) {
            return (options.find(function (o) {
              return o.value === v;
            }) || {}).name;
          }).filter(function (n) {
            return n;
          }).join('、');
        }

        return (options.find(function (o) {
          return o.value === value;
        }) || {}).name;
      }

      return value;
    };

    _this.renderCell = function () {
      var _this$props = _this.props,
          dataIndex = _this$props.dataIndex,
          record = _this$props.record,
          column = _this$props.column,
          index = _this$props.index,
          rowSelection = _this$props.rowSelection,
          rowKey = _this$props.rowKey,
          columnIndex = _this$props.columnIndex,
          disabledProps = _this$props.disabled;
      var cellKey = "".concat(dataIndex, "-").concat(columnIndex, "-").concat(rowKey ? rowKey(record, index) || index : index);

      if (dataIndex === ROW_SELECTION) {
        if (rowSelection) {
          var tdKey = rowKey(record, index);
          var checked = (rowSelection.selectedRowKeys || []).indexOf(tdKey) > -1;
          return /*#__PURE__*/React__default['default'].createElement("td", {
            key: "td-".concat(cellKey)
          }, rowSelection.type === 'radio' ? /*#__PURE__*/React__default['default'].createElement(antd.Radio, _extends({
            key: cellKey,
            checked: checked,
            value: tdKey,
            onChange: function onChange(e) {
              if (e.target.checked === checked) return;
              if (!rowSelection.onChange && !rowSelection.onSelect) return;
              var selectedRowKeys = [tdKey];

              if (rowSelection.onChange) {
                rowSelection.onChange(selectedRowKeys);
              }

              if (rowSelection.onSelect) {
                rowSelection.onSelect(record, e.target.checked, selectedRowKeys, e);
              }
            }
          }, _objectSpread2(_objectSpread2({}, rowSelection.getCheckboxProps && rowSelection.getCheckboxProps(record, index)), disabledProps ? {
            disabled: disabledProps
          } : null))) : /*#__PURE__*/React__default['default'].createElement(antd.Checkbox, _extends({
            key: cellKey,
            checked: checked,
            onChange: function onChange(e) {
              if (!rowSelection.onChange && !rowSelection.onSelect) return;
              var selectedRowKeys = [];

              if (e.target.checked && !checked) {
                selectedRowKeys = [].concat(_toConsumableArray(rowSelection.selectedRowKeys || []), [tdKey]);
              }

              if (!e.target.checked && checked) {
                selectedRowKeys = (rowSelection.selectedRowKeys || []).filter(function (k) {
                  return k !== tdKey;
                });
              }

              if (rowSelection.onChange) {
                rowSelection.onChange(selectedRowKeys);
              }

              if (rowSelection.onSelect) {
                rowSelection.onSelect(record, e.target.checked, selectedRowKeys, e);
              }
            }
          }, _objectSpread2(_objectSpread2({}, rowSelection.getCheckboxProps && rowSelection.getCheckboxProps(record, index)), disabledProps ? {
            disabled: disabledProps
          } : null))));
        }

        return /*#__PURE__*/React__default['default'].createElement("td", {
          key: "td-".concat(cellKey)
        });
      }

      var _ref = column || {},
          _ref$validateRules = _ref.validateRules,
          validateRules = _ref$validateRules === void 0 ? [] : _ref$validateRules,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? [] : _ref$options,
          columnType = _ref.formItemType,
          editable = _ref.editable,
          readonly = _ref.readonly,
          render = _ref.render,
          prefixElement = _ref.prefixElement,
          suffixElement = _ref.suffixElement,
          _ref$cellClassName = _ref.cellClassName,
          cellClassName = _ref$cellClassName === void 0 ? '' : _ref$cellClassName,
          columnShouldUpdate = _ref.shouldUpdate,
          restColumnProps = _objectWithoutProperties(_ref, _excluded$1);

      var _ref2 = record[dataIndex] || {},
          recordValidateRules = _ref2.validateRules,
          recordOptions = _ref2.options,
          recordType = _ref2.formItemType,
          recordEditable = _ref2.editable,
          recordReadonly = _ref2.readonly,
          recordRender = _ref2.render,
          recordShouldUpdate = _ref2.shouldUpdate,
          restRecordProps = _objectWithoutProperties(_ref2, _excluded2$1);

      var lEditable = recordEditable !== undefined ? recordEditable : editable;
      var lReadonly = recordReadonly || readonly;
      var disabled = lEditable === undefined ? false : !lEditable;
      var renderFn = recordRender || render;
      var formItemType = recordType || columnType || 'INPUT';
      var ops = recordOptions || options;

      var shouldUpdate = recordShouldUpdate || columnShouldUpdate || function (prevValue, curValue) {
        return prevValue !== curValue;
      };

      return /*#__PURE__*/React__default['default'].createElement("td", {
        key: "td-".concat(cellKey)
      }, /*#__PURE__*/React__default['default'].createElement("div", {
        className: typeof cellClassName === 'function' ? cellClassName(record[dataIndex], record, index) : cellClassName
      }, prefixElement ? prefixElement(record[dataIndex], record, index) : null, renderFn ? renderFn(record[dataIndex], record, index) : /*#__PURE__*/React__default['default'].createElement(antd.Form.Item, {
        style: {
          margin: 0
        },
        key: "form-item-".concat(cellKey),
        name: dataIndex,
        rules: recordValidateRules || validateRules || [],
        shouldUpdate: shouldUpdate
      }, lReadonly ? _this.renderName(getHasValue(record[dataIndex]) ? record[dataIndex].value : record[dataIndex], formItemType, ops) : /*#__PURE__*/React__default['default'].createElement(FormItemType, _extends({
        key: cellKey,
        disabled: disabledProps || disabled,
        formItemType: formItemType,
        options: ops
      }, _objectSpread2(_objectSpread2({}, lodashEs.omit(restColumnProps, ['value', 'onChange'])), lodashEs.omit(restRecordProps, ['value', 'onChange']))))), suffixElement ? suffixElement(record[dataIndex], record, index) : null));
    };

    return _this;
  }

  _createClass(EditableCell, [{
    key: "render",
    value: function render() {
      return this.renderCell();
    }
  }]);

  return EditableCell;
}(React.Component);

EditableCell.propTypes = {
  dataIndex: PropTypes__default['default'].string,
  record: PropTypes__default['default'].shape({}),
  index: PropTypes__default['default'].number,
  columnIndex: PropTypes__default['default'].number,
  disabled: PropTypes__default['default'].bool,
  column: PropTypes__default['default'].shape({
    render: PropTypes__default['default'].func,
    editable: PropTypes__default['default'].bool,
    readonly: PropTypes__default['default'].bool,
    formItemType: PropTypes__default['default'].oneOf(['RADIO', 'SELECT', 'INPUT', 'INPUT_NUMBER', 'TEXTAREA', 'DATE_PICKER', 'CASCADER', 'CHECKBOX', 'TREE_SELECT']),
    validateRules: PropTypes__default['default'].arrayOf(PropTypes__default['default'].object),
    options: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
      key: PropTypes__default['default'].string,
      name: PropTypes__default['default'].string,
      value: PropTypes__default['default'].string
    })),
    prefixElement: PropTypes__default['default'].func,
    suffixElement: PropTypes__default['default'].func,
    cellClassName: PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].func]),
    shouldUpdate: PropTypes__default['default'].func
  }),
  rowSelection: PropTypes__default['default'].shape({
    type: PropTypes__default['default'].oneOf(['radio', 'checkbox']),
    selectedRowKeys: PropTypes__default['default'].arrayOf(PropTypes__default['default'].string),
    onChange: PropTypes__default['default'].func,
    getCheckboxProps: PropTypes__default['default'].func
  }),
  rowKey: PropTypes__default['default'].func
};

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".editable-table-container .ant-form-item-control.has-error {\n  top: -8px !important;\n}\n.editable-table-container .ant-input-number {\n  width: 100%;\n}\n.editable-table-icon {\n  font-size: 16px !important;\n  margin-right: 10px;\n}\n.editable-table-icon :last-child {\n  margin-right: 0;\n}\n.editable-table-footer {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.editable-table-footer .editable-table-btn-wrap {\n  align-items: center;\n  display: flex;\n}\n.editable-table-footer .editable-table-btn-wrap .editable-table-plus-btn-icon {\n  cursor: pointer;\n  color: #c6c6c6;\n  font-weight: 700;\n  font-size: 16px;\n  margin-right: 5px;\n}\n.editable-table-footer .editable-table-btn-wrap .editable-table-plus-btn {\n  padding: 0;\n  width: auto;\n}\n.editable-table-header {\n  font-family: PingFangSC-Medium;\n  font-size: 14px;\n  color: #424242;\n  margin-bottom: 10px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n.editable-table-header .editable-table-header-extra {\n  display: flex;\n  align-items: center;\n}\n";
styleInject(css_248z);

var _excluded$2 = ["record", "myRowKey", "index", "validateFieldFns", "className", "children", "onChange", "columns"];
var cx = classnames(css_248z, CLASSNAME_PREFIX);

var EditableRow = function EditableRow(_ref) {
  var record = _ref.record,
      myRowKey = _ref.myRowKey,
      index = _ref.index,
      validateFieldFns = _ref.validateFieldFns,
      className = _ref.className,
      children = _ref.children,
      onChange = _ref.onChange,
      columns = _ref.columns,
      props = _objectWithoutProperties(_ref, _excluded$2);

  var formRef = React.useRef({});
  var rowKeyStr = "".concat(myRowKey ? myRowKey(record, index) || index : index);
  React.useEffect(function () {
    var validataFn = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var hasError, firstField;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                hasError = false;
                _context.prev = 1;

                if (!(formRef && formRef.current && formRef.current.validateFields)) {
                  _context.next = 5;
                  break;
                }

                _context.next = 5;
                return formRef.current.validateFields();

              case 5:
                _context.next = 11;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](1);
                firstField = ((((_context.t0 || {}).errorFields || [])[0] || {}).name || [])[0];

                if (firstField) {
                  if (formRef && formRef.current && formRef.current.submit) {
                    formRef.current.submit();
                  }

                  hasError = true;
                }

              case 11:
                return _context.abrupt("return", hasError);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 7]]);
      }));

      return function validataFn() {
        return _ref2.apply(this, arguments);
      };
    }();

    validateFieldFns.push(validataFn);
    return function () {
      validateFieldFns.splice(validateFieldFns.findIndex(function (v) {
        return v === validataFn;
      }), 1);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  var fields = [];
  var columMap = columns.reduce(function (reuslt, current) {
    return _objectSpread2(_objectSpread2({}, reuslt), {}, _defineProperty({}, current.dataIndex, current));
  }, {});
  Object.keys(record || {}).forEach(function (key) {
    if (key === ROW_SELECTION) return;
    var column = columMap[key];

    if (!column || column.render) {
      return;
    }

    var hasValue = getHasValue(record[key]);

    if (hasValue && record[key] && record[key].render) {
      return;
    }

    fields.push({
      name: key,
      value: hasValue ? record[key].value : record[key]
    });
  });
  return /*#__PURE__*/React__default['default'].createElement("tr", _extends({}, props, {
    key: rowKeyStr,
    className: cx('edit-row', className || '')
  }), /*#__PURE__*/React__default['default'].createElement(antd.Form, {
    ref: formRef,
    fields: fields,
    component: false,
    scrollToFirstError: true,
    onValuesChange: function onValuesChange(changedValues, allValues) {
      var key = Object.keys(changedValues)[0];
      var value = changedValues[key];
      var column = columns.find(function (c) {
        return c.dataIndex === key;
      }) || {};
      var hasValue = getHasValue(record[key]);

      if (hasValue) {
        var newRecord = _objectSpread2({}, record);

        if (!newRecord[key]) {
          newRecord[key] = {};
        }

        newRecord[key].value = value;
        onChange(key, value, newRecord, newRecord[key].formItemType || column.formItemType || 'INPUT');
      } else {
        onChange(key, value, Object.assign({}, record, allValues), column.formItemType || 'INPUT');
      }
    }
  }, children));
};

EditableRow.propTypes = {
  validateFieldFns: PropTypes__default['default'].arrayOf(PropTypes__default['default'].func),
  record: PropTypes__default['default'].shape({}),
  index: PropTypes__default['default'].number,
  myRowKey: PropTypes__default['default'].func,
  className: PropTypes__default['default'].string,
  onChange: PropTypes__default['default'].func,
  columns: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({})),
  children: PropTypes__default['default'].node
};

var _excluded$3 = ["rowClassName", "rowKey", "columns", "dataSource", "onChange", "rowSelection", "showAdd", "onAdd", "addText", "disabled", "header", "headerExtra", "className", "addBtnClassName"];
var cx$1 = classnames(css_248z, CLASSNAME_PREFIX);

var EditableTable = /*#__PURE__*/function (_Component) {
  _inherits(EditableTable, _Component);

  var _super = _createSuper(EditableTable);

  function EditableTable() {
    var _this;

    _classCallCheck(this, EditableTable);

    _this = _super.call(this);
    _this.validateField = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var result;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return Promise.all(_this.validateFieldFns.map(function (v) {
                return v();
              }));

            case 2:
              result = _context.sent;
              return _context.abrupt("return", lodashEs.some(result));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    _this.debounceChange = lodashEs.debounce(function (key, value, newRecord, newDataSource, index, rowKey) {
      var onChange = _this.props.onChange;
      onChange(key, value, newRecord, newDataSource, index, rowKey);
    }, 200);
    _this.validateFieldFns = [];
    return _this;
  }

  _createClass(EditableTable, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var getValidateFieldsMethod = this.props.getValidateFieldsMethod;

      if (getValidateFieldsMethod) {
        getValidateFieldsMethod(this.validateField);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          rowClassName = _this$props.rowClassName,
          rowKey = _this$props.rowKey,
          columns = _this$props.columns,
          dataSource = _this$props.dataSource,
          _onChange = _this$props.onChange,
          rowSelection = _this$props.rowSelection,
          showAdd = _this$props.showAdd,
          onAdd = _this$props.onAdd,
          addText = _this$props.addText,
          disabled = _this$props.disabled,
          header = _this$props.header,
          headerExtra = _this$props.headerExtra,
          className = _this$props.className,
          addBtnClassName = _this$props.addBtnClassName,
          restProps = _objectWithoutProperties(_this$props, _excluded$3);

      var components = {
        body: {
          row: EditableRow,
          cell: EditableCell
        }
      };
      var newColumns = columns;

      if (rowSelection) {
        newColumns = [{
          dataIndex: ROW_SELECTION,
          width: 40,
          title: function title() {
            var allKeys = [];
            (dataSource || []).forEach(function (record, index) {
              if (!rowSelection.getCheckboxProps || !disabled && !(rowSelection.getCheckboxProps(record, index) || {}).disabled) {
                allKeys.push(rowKey(record, index));
              }
            });
            var checked = (rowSelection.selectedRowKeys || []).length > 0 && !allKeys.find(function (key) {
              return !(rowSelection.selectedRowKeys || []).find(function (rk) {
                return rk === key;
              });
            });
            return /*#__PURE__*/React__default['default'].createElement("div", null, rowSelection.type === 'radio' || rowSelection.hideDefaultSelections ? null : /*#__PURE__*/React__default['default'].createElement(antd.Checkbox, {
              indeterminate: !checked && (rowSelection.selectedRowKeys || []).length > 0,
              checked: checked,
              disabled: disabled,
              onChange: function onChange(e) {
                if (!rowSelection.onChange) return;

                if (e.target.checked) {
                  rowSelection.onChange(allKeys);
                } else {
                  rowSelection.onChange([]);
                }
              }
            }));
          }
        }].concat(newColumns);
      }

      newColumns = newColumns.map(function (col, columnIndex) {
        return _objectSpread2(_objectSpread2({}, col), {}, {
          onCell: function onCell(record, index) {
            return {
              record: record,
              dataIndex: col.dataIndex,
              column: col,
              index: index,
              columnIndex: columnIndex,
              disabled: disabled,
              rowSelection: rowSelection,
              rowKey: rowKey
            };
          }
        });
      });
      return /*#__PURE__*/React__default['default'].createElement("div", {
        className: cx$1('container', ":".concat(className || ''))
      }, header ? /*#__PURE__*/React__default['default'].createElement("div", {
        className: cx$1('header')
      }, header, headerExtra && /*#__PURE__*/React__default['default'].createElement("div", {
        className: cx$1('header-extra')
      }, headerExtra)) : null, /*#__PURE__*/React__default['default'].createElement(antd.Table, _extends({
        rowKey: rowKey,
        onRow: function onRow(record, index) {
          return {
            record: record,
            myRowKey: rowKey,
            //必须改名，才能把rowKey传进去
            columns: newColumns,
            index: index,
            validateFieldFns: _this2.validateFieldFns,
            className: rowClassName && rowClassName(record, index),
            onChange: function onChange(key, value, newRecord, formItemType) {
              var newDataSource = _toConsumableArray(dataSource);

              var target = newDataSource[index];
              Object.assign(target, newRecord);

              if (typeof key === 'string') {
                if (['INPUT', 'TEXTAREA', 'INPUT_NUMBER'].includes(formItemType)) {
                  _this2.debounceChange(key, value, newRecord, newDataSource, index, rowKey && rowKey(newRecord));
                } else {
                  _onChange(key, value, newRecord, newDataSource, index, rowKey && rowKey(newRecord));
                }
              }
            }
          };
        },
        components: columns.length > 0 && dataSource.length > 0 ? components : undefined,
        dataSource: dataSource,
        columns: newColumns,
        footer: function footer() {
          return !disabled && showAdd && /*#__PURE__*/React__default['default'].createElement("div", {
            className: cx$1('footer')
          }, /*#__PURE__*/React__default['default'].createElement("div", {
            onClick: onAdd,
            role: "button",
            className: cx$1('btn-wrap', ":".concat(addBtnClassName || ''))
          }, /*#__PURE__*/React__default['default'].createElement(icons.PlusOutlined, {
            className: cx$1('plus-btn-icon')
          }), /*#__PURE__*/React__default['default'].createElement(antd.Button, {
            type: "link",
            className: cx$1('plus-btn')
          }, addText)));
        }
      }, restProps)));
    }
  }]);

  return EditableTable;
}(React.Component);

EditableTable.propTypes = {
  className: PropTypes__default['default'].string,
  header: PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].node]),
  headerExtra: PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].node]),
  showAdd: PropTypes__default['default'].bool,
  addBtnClassName: PropTypes__default['default'].string,
  onAdd: PropTypes__default['default'].func,
  addText: PropTypes__default['default'].string,
  disabled: PropTypes__default['default'].bool,
  rowClassName: PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].func]),
  rowKey: PropTypes__default['default'].func,
  dataSource: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
    validateRules: PropTypes__default['default'].arrayOf(PropTypes__default['default'].object),
    options: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
      key: PropTypes__default['default'].string,
      name: PropTypes__default['default'].string,
      value: PropTypes__default['default'].string
    }))
  })),
  rowSelection: PropTypes__default['default'].shape({
    type: PropTypes__default['default'].oneOf(['radio', 'checkbox']),
    selectedRowKeys: PropTypes__default['default'].arrayOf(PropTypes__default['default'].string),
    onChange: PropTypes__default['default'].func,
    getCheckboxProps: PropTypes__default['default'].func,
    hideDefaultSelections: PropTypes__default['default'].bool
  }),
  columns: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
    dataIndex: PropTypes__default['default'].string,
    key: PropTypes__default['default'].string,
    render: PropTypes__default['default'].func,
    formItemType: PropTypes__default['default'].oneOf(['RADIO', 'SELECT', 'INPUT', 'INPUT_NUMBER', 'TEXTAREA', 'DATE_PICKER', 'CASCADER', 'CHECKBOX', 'TREE_SELECT'])
  })),
  onChange: PropTypes__default['default'].func,
  getValidateFieldsMethod: PropTypes__default['default'].func
};
EditableTable.defaultProps = {
  rowKey: function rowKey(record, index) {
    return "".concat(index);
  }
};

module.exports = EditableTable;
